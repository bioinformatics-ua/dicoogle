/**
 * Copyright (C) 2014  Universidade de Aveiro, DETI/IEETA, Bioinformatics Group - http://bioinformatics.ua.pt/
 *
 * This file is part of Dicoogle/dicoogle-sdk.
 *
 * Dicoogle/dicoogle-sdk is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Dicoogle/dicoogle-sdk is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Dicoogle.  If not, see <http://www.gnu.org/licenses/>.
 */
package pt.ua.dicoogle.sdk.datastructs.dim;

import pt.ua.dicoogle.sdk.mlprovider.MLlabel;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * A bulk annotation object denotes a group of annotations from a DICOM file generated by third-party services like AI algorithms.
 * It follows the supplement 222 of the DICOM standard.
 * Annotations in a bulk annotation object share common attributes such as shape type, label, pixel origin, etc.
 * Check the module C.37.1.2 Microscopy Bulk Simple Annotations for more information on annotation bulks.
 * This object only maps certain parts of the standard, not the whole of it, as it is quite extensive.
 * For ease of use, this object maps annotations as a list of lists.
 * The standard stores all the annotations on a single list and uses a secondary list of indices to delimit the annotations.
 */
public class BulkAnnotation {

    /**
     * Denotes the pixel origin of the annotations contained in this bulk.
     */
    public enum PixelOrigin {
        /**
         * Coordinates of this annotation are related to the frame (image section)
         */
        FRAME,
        /**
         * Coordinates of this annotation are related to the Frame Matrix (whole image)
         */
        VOLUME
    }

    /**
     * Denotes the type of annotations contained in this bulk.
     */
    public enum AnnotationType {
        RECTANGLE, ELLIPSE, POLYGON, POLYLINE, POINT
    }

    /**
     * Denotes the type of coordinates contained in this bulk
     */
    public enum CoordinateType {
        /**
         * For image relative coordinates
         */
        TWO_DIMENSIONAL,
        /**
         * For coordinates in a Cartesian system defined by a frame of reference
         */
        THREE_DIMENSIONAL
    }

    private PixelOrigin pixelOrigin;

    private CoordinateType coordinateType;

    private AnnotationType annotationType;

    private MLlabel label;

    private List<List<Point2D>> annotations;

    public BulkAnnotation(AnnotationType type, PixelOrigin origin) {
        this.annotationType = type;
        this.pixelOrigin = origin;
        this.annotations = new ArrayList<>();
    }

    public BulkAnnotation(AnnotationType type, PixelOrigin origin, List<List<Point2D>> annotations) {
        this(type, origin);
        this.annotations = annotations;
    }

    public PixelOrigin getPixelOrigin() {
        return pixelOrigin;
    }

    public void setPixelOrigin(PixelOrigin pixelOrigin) {
        this.pixelOrigin = pixelOrigin;
    }

    public CoordinateType getCoordinateType() {
        return coordinateType;
    }

    public void setCoordinateType(CoordinateType coordinateType) {
        this.coordinateType = coordinateType;
    }

    public AnnotationType getAnnotationType() {
        return annotationType;
    }

    public void setAnnotationType(AnnotationType annotationType) {
        this.annotationType = annotationType;
    }

    public MLlabel getLabel() {
        return label;
    }

    public void setLabel(MLlabel label) {
        this.label = label;
    }

    public List<List<Point2D>> getAnnotations() {
        return annotations;
    }

    public void setAnnotations(List<List<Point2D>> annotations) {
        this.annotations = annotations;
    }

    public void addAnnotation(List<Point2D> annotation) {
        this.annotations.add(annotation);
    }

    public List<Point2D> getBoundingBox(List<Point2D> points) {
        return BulkAnnotation.getBoundingBox(this.annotationType, points);
    }

    /**
     * Calculate the bounding box of an annotation from this bulk.
     * @return a list of 4 points, representing a rectangle that contains the provided annotation.
     */
    public static List<Point2D> getBoundingBox(AnnotationType type, List<Point2D> points) {

        double minX = Double.MAX_VALUE;
        double minY = Double.MAX_VALUE;
        double maxX = Double.MIN_VALUE;
        double maxY = Double.MIN_VALUE;

        switch (type) {
            case RECTANGLE:
                return points; // In case of rectangles, annotations are already coded as the corners of the rectangle
            case POLYGON:
            case POLYLINE:
                for (Point2D p : points) {
                    if (p.getX() > maxX)
                        maxX = p.getX();
                    if (p.getX() < minX)
                        minX = p.getX();

                    if (p.getY() > maxY)
                        maxY = p.getY();
                    if (p.getY() < minY)
                        minY = p.getY();
                }
                break;
            case ELLIPSE:
                minX = points.get(0).getX();
                maxX = points.get(1).getX();
                minY = points.get(2).getY();
                maxY = points.get(3).getY();
                break;
        }

        Point2D tl = new Point2D(minX, minY);
        Point2D tr = new Point2D(maxX, minY);
        Point2D bl = new Point2D(minX, maxY);
        Point2D br = new Point2D(maxX, maxY);

        return Arrays.asList(tl, tr, bl, br);
    }

    /**
     * Given a list of points from this bulk, calculate its area.
     * @param points
     * @return
     */
    public double getArea(List<Point2D> points) {
        List<Point2D> bbox = this.getBoundingBox(points);
        double width = bbox.get(1).getX() - bbox.get(0).getX();
        double height = bbox.get(0).getY() - bbox.get(2).getY();
        return Math.abs(width * height);
    }

}
